//priority: 900
ServerEvents.recipes(e => {
    let itemUnifTagData = JsonIO.read('kubejs/datagen/itemTagUnificationData.json')
    if (!(itemUnifTagData == null)) {
        for (let tagObj of Object.entries(itemUnifTagData)) {
            if (tagObj[0].includes('ores')) { continue }
            e.replaceOutput({}, `#${tagObj[0]}`, tagObj[1].prefItem)
            for (let item of tagObj[1].toUnify) {
                if (item.includes('emendatus')) { continue }
                e.replaceOutput({}, item, tagObj[1].prefItem)
                e.replaceInput({}, item, tagObj[1].prefItem)
                e.remove({ output: item })
            }
        }
    }
    // basically just wanted this for embers sake but embers isnt kubejs plugin so replaces dont work :p
    // let fluidUnifTagData = JsonIO.read('kubejs/datagen/fluidTagUnificationData.json')
    // if (!(fluidUnifTagData == null)) {
    //     for (let fluidObj of Object.entries(fluidUnifTagData)) {
    //         for (let fluidToUnify of fluidObj[1].toUnify) {
    //             console.log(`replacing ${fluidToUnify} with ${fluidObj[1].prefFluid}`)
    //             e.replaceOutput({}, Fluid.of(fluidToUnify), Fluid.of(fluidObj[1].prefFluid))
    //             e.replaceInput({}, Fluid.of(fluidToUnify), Fluid.of(fluidObj[1].prefFluid))
    //             e.remove({ output: Fluid.of(fluidToUnify) })
    //         }
    //     }
    // }
})
ServerEvents.recipes(e => {
    // blacklisted materials that may have recipes already generated by another tagged item
    const materialBlacklist = ['niter', 'saltpeter', /* emerald fluid is bugged? */'emerald']
    // generating and removing un unified recipes
    for (let materialName of materialsToUnify) {
        if (materialBlacklist.includes(materialName)) { continue }
        let typesObj = {
            // general meterial types
            block: getTaggedItem(`forge:storage_blocks/${materialName}`),
            ingot: getTaggedItem(`forge:ingots/${materialName}`),
            nugget: getTaggedItem(`forge:nuggets/${materialName}`),
            // gem specific
            gem: getTaggedItem(`forge:gems/${materialName}`),
            chunk: getTaggedItem(`forge:chunks/${materialName}`),
            // general oreproc
            ore: getTaggedItem(`forge:ores/${materialName}`),
            raw_ore: getTaggedItem(`forge:raw_materials/${materialName}`),
            raw_ore_block: getTaggedItem(`forge:storage_blocks/raw_${materialName}`),
            crushed_ore: getTaggedItem(`forge:crushed_ores/${materialName}`),
            dust: getTaggedItem(`forge:dusts/${materialName}`),
            shard: getTaggedItem(`forge:shards/${materialName}`),
            // mekanism oreproc
            mek_crystal: getTaggedItem(`forge:crystals/${materialName}`),
            mek_shard: getTaggedItem(`forge:shards/${materialName}`),
            mek_clump: getTaggedItem(`forge:clumps/${materialName}`),
            // bloodmagic oreproc
            fragment: getTaggedItem(`forge:fragments/${materialName}`),
            gravel: getTaggedItem(`forge:gravels/${materialName}`),
            // enigmatica magic oreproc
            mana_cluster: getTaggedItem(`enigmatica:mana_clusters/${materialName}`),
            fulminated_cluster: getTaggedItem(`enigmatica:fulminated_clusters/${materialName}`),
            levigated_material: getTaggedItem(`enigmatica:levigated_materials/${materialName}`),
            crystalline_sliver: getTaggedItem(`enigmatica:crystalline_slivers/${materialName}`),
            // components
            gear: getTaggedItem(`forge:gears/${materialName}`),
            rod: getTaggedItem(`forge:rods/${materialName}`),
            plate: getTaggedItem(`forge:plates/${materialName}`),
            wire: getTaggedItem(`forge:wires/${materialName}`),
            coin: getTaggedItem(`forge:coins/${materialName}`),
            // special
            fluid: getFluid(materialName),
        }
        typesObj['gemOrIngot'] = typesObj.gem || typesObj.ingot
        typesObj['smeltable'] = [typesObj.raw_ore, typesObj.crushed_ore, typesObj.dust]
        // console.log(`material: ${materialName}`, Object.entries(typesObj).map(entry => `${entry[0]}: ${entry[1] == undefined ? 'undefined' : entry[1].item ? entry[1].item.id : entry[1]}`), ` - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - `)
        smeltingRecipes(e, materialName, typesObj)
        plateRecipes(e, materialName, typesObj)
        rodRecipes(e, materialName, typesObj)
        gearRecipes(e, materialName, typesObj)
        wireRecipes(e, materialName, typesObj)
        materialCompacting(e, materialName, typesObj)
        scrapMelting(e, materialName, typesObj)
        materialCrushing(e, materialName, typesObj)
        fluidToItemRecipes(e, materialName, typesObj)
    }
    // clear obj for memory sake or something
})

function smeltingXp(materialType, recipe) {
    if (/raw.*block/.test(materialType) && !materialType.includes('raw_redstone')) { recipe.xp(6); return }
    if (materialType.includes('raw') && !materialType.includes('raw_redstone')) { recipe.xp(0.7); return }
    if (materialType.includes('ores')) { recipe.xp(2); return }
}

function smeltingRecipes(e, materialName, typesObj) {
    // added to an empty string to convert to a normal js string instead of java
    if (!typesObj.gemOrIngot) { return }

    let gemOrIngotItem = typesObj.gemOrIngot.item.id + ''
    let gemOrIngotItemName = gemOrIngotItem.split(':')[1]

    let smeltableItems = []
    for (let smelt of typesObj.smeltable) {
        if (smelt) { smeltableItems.push(smelt.item.id) }
    }
    if (typesObj.ore) { smeltableItems.push(`#${typesObj.ore.tag}`) }

    e.remove({ output: gemOrIngotItem, type: 'minecraft:smelting' })
    e.remove({ output: gemOrIngotItem, type: 'minecraft:blasting' })

    for (let toSmelt of smeltableItems) {
        if (!toSmelt) { continue }
        let toSmeltName = toSmelt.split(':')[1]

        let blast = e.blasting(gemOrIngotItem, toSmelt)
            .id(`emendatus:blasting/${toSmeltName}_to_${gemOrIngotItemName}`)
        smeltingXp(toSmelt, blast)

        let furnace = e.recipes.thermal.furnace(gemOrIngotItem, toSmelt)
            .id(`emendatus:thermal/furnace/${toSmeltName}_to_${gemOrIngotItemName}`)
        smeltingXp(toSmelt, furnace)

        e.recipes.mekanism.smelting(gemOrIngotItem, toSmelt)
            .id(`emendatus:mekanism/smelting/${toSmeltName}_to_${gemOrIngotItemName}`)
    }

    if (typesObj.raw_ore_block && typesObj.block) {
        let toSmelt = typesObj.raw_ore_block.item.id
        let toSmeltName = toSmelt.split(':')[1]
        let block = typesObj.block.item.id
        let blast = e.blasting(block, toSmelt)
            .id(`emendatus:blasting/${toSmeltName}_to_${gemOrIngotItemName}`)
        smeltingXp(toSmelt, blast)

        let furnace = e.recipes.thermal.furnace(block, toSmelt)
            .id(`emendatus:thermal/furnace/${toSmeltName}_to_${gemOrIngotItemName}`)
        smeltingXp(toSmelt, furnace)

        e.recipes.mekanism.smelting(block, toSmelt)
            .id(`emendatus:mekanism/smelting/${toSmeltName}_to_${gemOrIngotItemName}`)
    }
}

function plateRecipes(e, materialName, typesObj) {
    if (!(typesObj.gemOrIngot && typesObj.plate)) { return }
    // added to an empty string to convert to a normal js string instead of java
    let gemOrIngotItem = typesObj.gemOrIngot.item.id + ''
    let plateItem = typesObj.plate.item.id + ''
    e.remove({ output: plateItem, input: gemOrIngotItem })
    if (typesObj.fluid) {
        let fluid = typesObj.fluid
        let fluidAmt = getFluidAmountForType(typesObj.gemOrIngot.tag)
        thermalChiller(e, plateItem, ['tconstruct:plate_cast', { fluid_tag: fluid.tag, amount: fluidAmt }])
            .id(`emendatus:thermal/chiller/${materialName}_plate`)
        embersStamping(e, `3x ${plateItem}`, { tag: fluid.tag, amount: fluidAmt * 3 }, 'embers:plate_stamp')
            .id(`emendatus:embers/stamping/${materialName}_plate`)
    }
    e.recipes.create.pressing(plateItem, gemOrIngotItem)
        .id(`emendatus:create/pressing/${materialName}_plate`)
    e.recipes.thermal.press(plateItem, gemOrIngotItem)
        .id(`emendatus:thermal/press/${materialName}_plate`)
    e.recipes.immersiveengineering.metal_press(`4x ${plateItem}`, `4x ${gemOrIngotItem}`)
        .mold('immersiveengineering:mold_plate')
        .id(`emendatus:immersiveengineering/metalpress/${materialName}_plate`)
    e.custom({
        type: "createdieselgenerators:hammering",
        ingredients: makeJsonIngredients(gemOrIngotItem),
        results: makeJsonIngredients(plateItem)
    }).id(`emendatus:createdieselgenerators/hammering/${materialName}_plate`)

    e.shaped(plateItem, [
        'H  ',
        'I  ',
        'I  ',
    ], {
        H: 'immersiveengineering:hammer',
        I: gemOrIngotItem
    }).id(`emendatus:hammer/${materialName}_plate`)
}

function rodRecipes(e, materialName, typesObj) {
    if (!(typesObj.gemOrIngot && typesObj.rod)) { return }
    let gemOrIngotItem = typesObj.gemOrIngot.item.id + ''
    let rodItem = typesObj.rod.item.id + ''

    e.remove({ output: rodItem })

    if (typesObj.fluid) {
        let fluid = typesObj.fluid
        let fluidAmt = getFluidAmountForType(typesObj.gemOrIngot.tag) / 2

        thermalChiller(e, rodItem, ['tconstruct:plate_cast', { fluid_tag: fluid.tag, amount: fluidAmt }])
            .id(`emendatus:thermal/chiller/${materialName}_rod`)
        embersStamping(e, `3x ${rodItem}`, { tag: fluid.tag, amount: fluidAmt * 3 }, 'immersiveengineering:mold_rod')
            .id(`emendatus:embers/stamping/${materialName}_rod`)
    }

    e.recipes.thermal.press(`2x ${rodItem}`, [gemOrIngotItem, 'immersiveengineering:mold_rod'])
        .id(`emendatus:thermal/press/${materialName}_rod`)
    e.recipes.immersiveengineering.metal_press(`8x ${rodItem}`, `4x ${gemOrIngotItem}`)
        .mold('immersiveengineering:mold_rod')
        .id(`emendatus:immersiveengineering/metalpress/${materialName}_rod`)

    e.custom({
        type: "createaddition:rolling",
        input: makeJsonIngredient(gemOrIngotItem),
        result: { item: rodItem, count: 2 }
    }).id(`emendatus:createaddition/rolling/${materialName}_rod`)

    e.custom({
        type: "createdieselgenerators:wire_cutting",
        ingredients: makeJsonIngredients(gemOrIngotItem),
        results: [{ item: rodItem, count: 2 }]
    }).id(`emendatus:createdieselgenerators/wire_cutting/${materialName}_rod`)

    e.shaped(`2x ${rodItem}`, [
        'IH ',
        'I  '
    ], {
        H: 'immersiveengineering:hammer',
        I: gemOrIngotItem
    }).id(`emendatus:hammer/${materialName}_rod`)
}

function gearRecipes(e, materialName, typesObj) {
    if (!(typesObj.gemOrIngot && typesObj.gear)) { return }

    let gemOrIngotItem = typesObj.gemOrIngot.item.id + ''
    let gearItem = typesObj.gear.item.id + ''

    e.remove({ output: gearItem })

    if (typesObj.fluid) {
        let fluid = typesObj.fluid
        let fluidAmt = getFluidAmountForType(typesObj.gemOrIngot.tag) * 4

        thermalChiller(e, gearItem, ['tconstruct:plate_cast', { fluid_tag: fluid.tag, amount: fluidAmt }])
            .id(`emendatus:thermal/chiller/${materialName}_gear`)
        embersStamping(e, `3x ${gearItem}`, { tag: fluid.tag, amount: fluidAmt * 3 }, 'embers:gear_stamp')
            .id(`emendatus:embers/stamping/${materialName}_gear`)
    }

    e.recipes.thermal.press(gearItem, [`4x ${gemOrIngotItem}`, 'immersiveengineering:mold_gear'])
        .id(`emendatus:thermal/press/${materialName}_gear`)
    e.recipes.immersiveengineering.metal_press(`4x ${gearItem}`, `16x ${gemOrIngotItem}`)
        .mold('immersiveengineering:mold_gear')
        .id(`emendatus:immersiveengineering/metalpress/${materialName}_gear`)

    e.shaped(gearItem, [
        'NIN',
        "IPI",
        'NIN',
    ], {
        N: '#forge:nuggets/aluminum',
        I: gemOrIngotItem,
        P: '#forge:plates/iron_tin'
    }).id(`emendatus:shaped/${materialName}_gear`)

}

function wireRecipes(e, materialName, typesObj) {
    if (!typesObj.wire || !typesObj.gemOrIngot) { return }

    let gemOrIngotItem = typesObj.gemOrIngot.item.id + ''
    let wireItem = typesObj.wire.item.id + ''

    e.remove({ output: wireItem })

    if (typesObj.fluid) {
        let fluid = typesObj.fluid
        let fluidAmt = getFluidAmountForType(typesObj.gemOrIngot.tag) / 2

        thermalChiller(e, wireItem, ['tconstruct:plate_cast', { fluid_tag: fluid.tag, amount: fluidAmt }])
            .id(`emendatus:thermal/chiller/${materialName}_wire`)
        embersStamping(e, `3x ${wireItem}`, { tag: fluid.tag, amount: fluidAmt * 3 }, 'immersiveengineering:mold_wire')
            .id(`emendatus:embers/stamping/${materialName}_wire`)
    }
    e.recipes.thermal.press(`2x ${wireItem}`, [gemOrIngotItem, 'immersiveengineering:mold_wire'])
        .id(`emendatus:thermal/press/${materialName}_wire`)
    e.recipes.immersiveengineering.metal_press(`8x ${wireItem}`, `4x ${gemOrIngotItem}`)
        .mold('immersiveengineering:mold_wire')
        .id(`emendatus:immersiveengineering/metalpress/${materialName}_wire`)
    if (typesObj.plate) {
        let plate = typesObj.plate.item.id + ''
        e.recipes.create.cutting(`2x ${wireItem}`, plate)
            .id(`emendatus:create/cutting/${materialName}_wire`)
        e.custom({
            type: "createdieselgenerators:wire_cutting",
            ingredients: makeJsonIngredients(plate),
            results: makeJsonIngredients(`2x ${wireItem}`)
        }).id(`emendatus:createdieselgenerators/wire_cutting/${materialName}_wire`)
        e.shaped(wireItem, [
            'AB '
        ], {
            A: plate,
            B: 'immersiveengineering:wirecutter'
        }).id(`emendatus:shaped/${materialName}_wire`)
    }
}

function materialCompacting(e, materialName, typesObj) {
    if (!(typesObj.gemOrIngot)) { return }
    let gemOrIngotItem = typesObj.gemOrIngot.item.id + ''
    let gemOrIngotItemName = gemOrIngotItem.split(':')[1]
    if (typesObj.gemOrIngot && typesObj.block) {
        let block = typesObj.block.item.id + ''
        let blockName = block.split(':')[1]
        e.remove({ output: block, input: gemOrIngotItem })
        e.remove({ output: gemOrIngotItem, input: block })
        e.shaped(block, [
            'III',
            'III',
            'III'
        ], {
            I: gemOrIngotItem
        }).id(`emendatus:shaped/compress_${blockName}`)
        e.recipes.thermal.press(block, [`9x ${gemOrIngotItem}`, 'thermal:press_packing_3x3_die'])
            .id(`emendatus:thermal/press/compress_${blockName}`)
        e.shapeless(`9x ${gemOrIngotItem}`, block)
            .id(`emendatus:shapeless/decrompress_${blockName}`)
        e.recipes.thermal.press(`9x ${gemOrIngotItem}`, [block, 'thermal:press_unpacking_die'])
            .id(`emendatus:thermal/press/decrompress_${blockName}`)
    }
    if (typesObj.gemOrIngot && typesObj.nugget) {
        let nugget = typesObj.nugget.item.id + ''
        e.remove({ output: gemOrIngotItem, input: nugget })
        e.remove({ output: nugget, input: gemOrIngotItem })
        e.shaped(gemOrIngotItem, [
            'III',
            'III',
            'III'
        ], {
            I: nugget
        }).id(`emendatus:shaped/compress_${gemOrIngotItemName}`)
        e.recipes.thermal.press(gemOrIngotItem, [`9x ${nugget}`, 'thermal:press_packing_3x3_die'])
            .id(`emendatus:thermal/press/compress_${gemOrIngotItemName}`)
        e.shapeless(`9x ${nugget}`, gemOrIngotItem)
            .id(`emendatus:shapeless/decompress_${gemOrIngotItemName}`)
        e.recipes.thermal.press(`9x ${nugget}`, [gemOrIngotItem, 'thermal:press_unpacking_die'])
            .id(`emendatus:thermal/press/decompress_${gemOrIngotItemName}`)
    }
}

function scrapMelting(e, materialName, typesObj) {
    if (!typesObj.fluid || !typesObj.gemOrIngot) { return }
    let fluid = typesObj.fluid

    for (let itemType of typesToUnify) {
        if (!typesObj[itemType]) { continue }
        let melt = meltingValues(getFluidAmountForType(typesObj.gemOrIngot.tag))[itemType]
        if (!melt) { continue }

        let item = typesObj[itemType].item.id + ''
        let fluidAmt = melt.amount
        let energy = melt.energy
        e.recipes.thermal.crucible(Fluid.of(fluid.stack.id, fluidAmt), item, 0, energy)
            .id(`emendatus:thermal/crucible/${item.split(':')[1]}`)
        if (500 > fluidAmt) {
            embersMelting(e, Fluid.of(fluid.stack.id, fluidAmt), item)
                .id(`emendatus:embers/melting/${item.split(':')[1]}`)
        }
    }
}

const crushable = ['gemOrIngot', 'plate']
function materialCrushing(e, materialName, typesObj) {
    if (!typesObj.gemOrIngot) { return }
    if (!typesObj.dust) { return }

    let dustItem = typesObj.dust.item.id + ''

    for (let type of crushable) {
        if (!typesObj[type]) { continue }
        let itemToCrush = typesObj[type].item.id + ''

        e.remove({ type: 'minecraft:crafting', input: itemToCrush, output: dustItem })
        e.shaped(dustItem, [
            'H  ',
            'I  '
        ], {
            H: 'immersiveengineering:hammer',
            I: itemToCrush
        }).id(`emendatus:crushing/hammer/${itemToCrush.split(':')[1]}_to_dust`)

        e.remove({ type: 'immersiveengineering:crusher', input: itemToCrush, output: dustItem })
        e.recipes.immersiveengineering.crusher(dustItem, itemToCrush, [], 3000)
            .id(`emendatus:crushing/immersiveengineering/crusher/${itemToCrush.split(':')[1]}_to_dust`)

        e.remove({ type: 'mekanism:crusher', input: itemToCrush, output: dustItem })
        e.recipes.mekanism.crushing(dustItem, itemToCrush)
            .id(`emendatus:crushing/mekanism/crusher/${itemToCrush.split(':')[1]}_to_dust`)
        //pedestals
        e.remove({ type: 'thermal:pulvizer', input: itemToCrush, output: dustItem })
        e.recipes.thermal.pulverizer(dustItem, itemToCrush)
            .id(`emendatus:crushing/thermal/pulverizer/${itemToCrush.split(':')[1]}_to_dust`)

        e.remove({ type: 'bloodmagic:arc', input: itemToCrush, output: dustItem })
        e.recipes.bloodmagic.arc(dustItem, itemToCrush, '#bloodmagic:arc/explosive')
            .id(`emendatus:crushing/bloodmagic/arc/${itemToCrush.split(':')[1]}_to_dust`)

        e.remove({ type: 'create:crushing', input: itemToCrush, output: dustItem })
        e.recipes.create.crushing(dustItem, itemToCrush)
            .id(`emendatus:crushing/create/crushing/${itemToCrush.split(':')[1]}_to_dust`)

        e.remove({ type: 'create:milling', input: itemToCrush, output: dustItem })
        e.recipes.create.milling(dustItem, itemToCrush)
            .id(`emendatus:crushing/create/milling/${itemToCrush.split(':')[1]}_to_dust`)

        e.remove({ type: 'occultism:crushing', input: itemToCrush, output: dustItem })
        e.recipes.occultism.crushing(dustItem, itemToCrush)
            .id(`emendatus:crushing/occultism/crushing/${itemToCrush.split(':')[1]}_to_dust`)

        e.remove({ type: 'ars_nouveau:crush', input: itemToCrush, output: dustItem })
        e.recipes.ars_nouveau.crush(Item.of(itemToCrush), Item.of(dustItem).withChance(1))
            .id(`emendatus:crushing/ars_nouveau/crush/${itemToCrush.split(':')[1]}_to_dust`)
    }
}

function fluidToItemRecipes(e, materialName, typesObj) {
    if (!typesObj.gemOrIngot) { return }

    let gemOrIngotItem = typesObj.gemOrIngot.item.id + ''

    if (typesObj.fluid) {
        let fluidAmt = getFluidAmountForType(typesObj.gemOrIngot.tag)
        let fluid = typesObj.fluid

        thermalChiller(e, gemOrIngotItem, ['tconstruct:ingot_cast', { fluid_tag: fluid.tag, amount: fluidAmt }])
            .id(`emendatus:thermal/chiller/${gemOrIngotItem.split(':')[1]}`)
        embersStamping(e, `3x ${gemOrIngotItem}`, { tag: fluid.tag, amount: fluidAmt * 3 }, 'embers:ingot_stamp')
            .id(`emendatus:embers/stamping/${gemOrIngotItem.split(':')[1]}`)
    }
}